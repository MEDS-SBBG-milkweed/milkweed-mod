```{r}

#Read the point data
milkweed_path <- here::here("~/../../capstone/milkweedmod/data/milkweed_polygon_data/")
milkweed_data_raw <- st_read(milkweed_path)
# remove "No" observations
milkweed_presence <- milkweed_data_raw |> 
  janitor::clean_names() |> 
  filter(milkweed_p != "no")  %>%
  st_transform(crs(envs_Ac)) %>%
  filter(milkweed_sp == "Asclepias californica") %>%
  dplyr::select(milkweed_sp)

# make points
multi.p <- st_cast(milkweed_presence, "MULTIPOINT")
my_points <- multi.p  %>% st_cast("POINT")

milkweed_points <- my_points %>%
  st_coordinates() %>%
  data.frame() %>%
  mutate(scientific_name = "Asclepias californica") %>%
  mutate(occID = row_number()) %>%
  rename(longitude = X,
         latitude = Y)

##########################################################################
# Env layers
##########################################################################
# Read in bioclim, canopy, slope, and aspect data
bioclim <- brick(here::here("~/../../capstone/milkweedmod/data/bioclim/wallace_bioclim.tif"))
canopy <- raster(here::here("~/../../capstone/milkweedmod/data/canopy_cover/canopy_cover_cleaned.tif"))
slope <- raster(here::here("~/../../capstone/milkweedmod/data/dem/lpnf_slope.tif"))
aspect <- raster(here::here("~/../../capstone/milkweedmod/data/dem/lpnf_aspect.tif"))

# crop to forest_buffer
bioclim_crop <- crop(bioclim, boundary_buffered)
canopy_crop <- crop(canopy, boundary_buffered)
slope_crop <- crop(slope, boundary_buffered)
aspect_crop <- crop (aspect, boundary_buffered)

# resoource: https://gis.stackexchange.com/questions/403536/raster-extent-issue-in-r
bioclim_crop_resample <- resample(bioclim_crop, canopy_crop)
aspect_crop_resample <- resample(aspect_crop, canopy_crop)
slope_crop_resample <- resample(slope_crop, canopy_crop)

canopy_crop <- mask(canopy_crop, bioclim_crop_resample)
aspect_crop_resample <- mask(aspect_crop_resample, bioclim_crop_resample)
slope_crop_resample <- mask(slope_crop_resample, bioclim_crop_resample)

# stack
envs_Ac <- raster::stack(bioclim_crop_resample, canopy_crop, slope_crop_resample, aspect_crop_resample)


###################################################################################
# OBTAINING CURRENT POTENTIAL DISTRIBUTION OR SPECIES SUITABILITY MODEL
###################################################################################

library("raster")
library("dismo")
library("rgeos")
library("rJava")


#For our models we want to use only one occurrence point per pixel, so we need to thin our occurrence data.
cells <- cellFromXY(envs_Ac[[1]], milkweed_points) #using as a reference our bio1 from our raster stack
dups <- duplicated(cells)
coords_final <- milkweed_points[!dups, ]
nrow(milkweed_points)
coords_final


#Let's create a background set of points for our model:
#*# Select background points from this buffered area; when the number provided 
# to set.seed() function, the same random sample will be selected in the next line			
# use this code before the sampleRandom function every time, if you want to get
# the same "random samples"
set.seed(1) 
bg <- sampleRandom(x=envs_Ac,
                   size=5000,
                   na.rm=T, #removes the 'Not Applicable' points  
                   sp=T) # return spatial points 

plot(envs_Ac[[1]])
# add the background points to the plotted raster
plot(bg,add=T) 
# add the occurrence data to the plotted raster
#plot(coords_final,col="red")
dev.off()



# The first thing we need to do is to get some data to train our model and some for testing it later
#Split occurrence data into training & testing:
#We randomly selected 70% of the occurrence data for model training and used the remaining for model testing. To make our experiment reproducible (i.e., select the same set of points), 
#we used a static seed via set.seed(1) function.
# get the same random sample for training and testing
set.seed(1)
# randomly select 70% for training
selected <- sample(1:nrow(milkweed_points), nrow(milkweed_points) * 0.7)
occ_train <- milkweed_points[selected, ]  # this is the selection to be used for model training
occ_test <- milkweed_points[-selected, ]  # this is the opposite of the selection which will be used for model testing

occ_train <- occ_train %>%
  select(longitude, latitude)

occ_test <- occ_test %>%
  select(longitude, latitude)


#Format data for Maxent The data input can either be spatial or tabular. 
#In our example, we use the tabular format, which can be potentially more flexible. 
#We extract environmental conditions for background, training, and testing points in a dataframe format
#extracting env conditions for training occ from the raster
p <- raster::extract(envs_Ac, occ_train)
# env conditions for testing occ
p_test <- raster::extract(envs_Ac, occ_test)
# extracting env conditions for background
a <- raster::extract(envs_Ac, bg)

a

#Maxent reads a "1" as presence and "0" as pseudo-absence. 
#Thus, we need to assign a "1" to the training environmental conditions and a "0" for the background. 
#We create a set of rows with the same number as the training and testing data, and put the value of "1" for each cell and a "0" for background. 
#We combine the "1"s and "0"s into a vector that was added to the dataframe containing the environmental conditions associated with the testing and background conditions.

# repeat the number 1 as many numbers as the number of rows
# in p, and repeat 0 as the rows of background points
pa <- c(rep(1, nrow(p)), rep(0, nrow(a)))

# (rep(1,nrow(p)) creating the number of rows as the p data
# set to have the number '1' as the indicator for presence;
# rep(0,nrow(a)) creating the number of rows as the a data
# set to have the number '0' as the indicator for absence;
# the c combines these ones and zeros into a new vector that
# can be added to the Maxent table data frame with the
# environmental attributes of the presence and absence
# locations
pder <- as.data.frame(rbind(p, a))



# train Maxent with tabular data
mod <- maxent(x=pder, ## env conditions
              p=pa,   ## 1:presence or 0:absence
              
              path=paste0("./output/maxent_outputs"), ## folder for maxent output; 
              # if we do not specify a folder R will put the results in a temp file, 
              # and it gets messy to read those. . .
              args=c("responsecurves") ## parameter specification
)
# the maxent functions runs a model in the default settings. To change these parameters,
# you have to tell it what you want...i.e. response curves or the type of features

# view the maxent model in a html brower
mod_results <- mod@results %>%
  data.frame()

# plot showing importance of each variable
plot(mod) #In this graph we can see the contribution of each bioclimatic variable in training the model. 
dev.off()
# response curves
response(mod)

####################
#Evaluate model
###################
#In other words, we can see if the model is good or bad. 
#Evaluation indices include AUC, TSS, Sensitivity, Specificity, etc.
#To evaluate models, we use the evaluate function from the "dismo" package

# 1. using 'training data' to evaluate.
#p & a are dataframe/s - the p and a are the training presence and background points

mod_eval_train <- dismo::evaluate(p = p, a = a, model = mod)
print(mod_eval_train)
plot(mod_eval_train,'ROC')

#In the plot above we are calculating the Area Under Curve
#The greater the AUC value is from 0.5, the better is our model.
#Now let's evaluate the model with our test data:
mod_eval_test <- dismo::evaluate(p = p_test, a = a, model = mod)
print(mod_eval_test)  # training AUC may be higher than testing AUC
plot(mod_eval_test,'ROC')


#################################
# Predicting habitat suitability
##################################
#Predict function Running Maxent in R will not automatically make projection to layers, unless you specify this using the parameter projectionlayers. 
#However, we could make projections (to dataframes or raster layers) post hoc using the predict function.


# example 1, project to study area [raster] - in this case the cropped env for CA
ped1 <- predict(mod, envs_Ac)  # studyArea is the clipped rasters 
plot(ped1)  # plot the continuous prediction
#Green areas are the best (near to 1) for the occurrence of Acmispon strigosus

#Making a better plot to see where the points fall:
plot(ped1, main ="Suitability of A. californica")
points(milkweed_points$longitude, milkweed_points$latitude, col=rgb(0,0,139,255*0.4,maxColorValue = 255),pch=20, cex=0.5)


#Generate map
m <- leaflet() %>% addProviderTiles(providers$Esri.WorldTopoMap) 
m  %>%
  addCircleMarkers(data = milkweed_points, lat = ~latitude, lng = ~longitude,
                   radius = 2, color = 'black', fill = TRUE, fillColor = "black",
                   fillOpacity = 0.2, weight = 2) %>% 
  ##Add model prediction
  addRasterImage(ped1, opacity = 0.7)
```

