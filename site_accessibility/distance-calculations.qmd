---
author: "Anna Ramji"
title: "Distance Calculations for Site Accessibility"
---

# Calculating distance from raster cell centroids to roads & trails

## Setup


### Load Packages
```{r library}
# load necessary packages
library(tidyverse)
library(janitor)
library(sf)
library(ggspatial)
library(terra)
library(here)
library(leaflet)
library(stars)
library(gdistance)
```

### Read in Data
```{r data}
# read in data ----

# ------ LPNF boundary shapefiles ---------
# Southern region
lpnf_boundary_south <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_south/lpnf_boundary_south.shp"))

# Northern region (once we have trail and road data for the North)
lpnf_boundary_north <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_north/lpnf_boundary_north.shp"))


# ------ Trails & Roads shapefile ----------------
# read in LPNF trails data 
trails_and_roads <- st_read(here("~/../../capstone/milkweedmod/raw_data/trails_and_roads/2023_Regional_Trails_and_Roads_lines/2023_Regional_Trails_and_Roads_lines.shp"))


# -------- Model raster ---------------------------
# We'll read in a .tif of the species distribution model output 
# to use as a template when we convert our shapefiles into rasters

# first as a SpatRaster (terra), to perform reclassification 
model_spat_raster <- terra::rast(here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# then as a RasterLayer (raster), to extract points in our distance calculation steps
model_raster_layer <- raster::raster(model_spat_raster)

# finally, the template needs to be a stars object when we rasterize with st_rasterize(), 
stars_temp_raster <- stars::read_stars(here::here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# optional data exploration/visualization
# plot(model_spat_raster)
# head(trails_and_roads)
# st_crs(model_raster_layer)
```

## Wrangle & tidy data

As we're working with geospatial data, it's important to make sure that our data is projected in the same coordinate reference system (CRS), and that it shares the same resolution and extent when we go to plot or combine multiple geospatial data elements. 

We are working in World Geodetic System 1984 (WGS 84) **EPSG 4326**. Fortunately, our tidied data (LPNF boundary and model output raster) are already in this CRS. 

```{r check}
# double-check to see that our data is in the same CRS
print("The CRS of the LPNF boundary and the model output match:")
st_crs(lpnf_boundary_south) == st_crs(model_spat_raster)

print("The CRS of the model output and the Trails & Roads data match:")
st_crs(model_spat_raster) == st_crs(trails_and_roads)
```
As the Trails & Roads data is not in the same CRS, we'll start by reprojecting the trails & roads data to match, and then create two subsets for trail data and road data (all in the Southern region of the forest.)
**[Note: we'll change this part once we have our cleaned data products script working]**

```{r tidy}
# ------- tidy trails & roads data -----------------
trails_roads_reprojected <- trails_and_roads %>% 
  st_transform(crs = st_crs(lpnf_boundary_south)) %>% # reproject CRS to EPSG 4326
  st_zm() %>%  # remove z-dimension
  janitor::clean_names() # tidy up column names


# check that crs match
print("The CRS of the model output and the Trails & Roads data match:")
st_crs(lpnf_boundary_south) == st_crs(trails_roads_reprojected)
```

### Create subsets

Here we'll separate the trails & roads data into two separate datasets -- trails and roads -- before selecting relevant columns to use when calculating distance.

*Note: we are not taking closed or limited-access roads or trails into account in our model and index creation -- if the trail or road exists, we're counting it. If you want to omit certain types of roads/trails, you can filter out certain variables to make updated subsets using `dplyr::filter(variable_name == "Condition")`, where "Condition" is whatever condition you've identified when `View`ing the dataframe.

```{r tidy}
# note: the geometries are MULTILINESTRINGS 
# (lines that have multiple + different start and end points)

# trails subset
only_trails <- trails_roads_reprojected %>% 
  filter(type == "Trail") %>%   # 1283 observations
  dplyr::select(type, geometry) # select relevant columns

# roads subset
only_roads <- trails_roads_reprojected %>% 
  filter(type == "Road") %>%  # 744 obs
  dplyr::select(type, geometry) # select relevant columns

# optional data exploration/visualization
# plot(only_trails)
# plot(only_roads)

# write files to clean_data folder ----
# st_write(only_trails, "~/../../capstone/milkweedmod/data/clean_data/trails_roads/forest_trails_south.shp")

#st_write(only_roads, "~/../../capstone/milkweedmod/data/clean_data/trails_roads/forest_roads_south.shp")

```


## Model Raster

### Raster reclassification: 
**Make a blank *template* for baseline distance calculations **

(Note: If we were working with a shapefile instead of a raster, we could simply add a column of 0s (or 1s), then rasterize, as we did when working with the land ownership mask).

First, we'll find the minimum and maximum values of our model raster, then create a reclassification matrix which will have 3 values: min, max, and 0. Then, we'll use that matrix to reclassify the model raster such that all values from min to max are equal to 0.

```{r reclassify-raster}
# pull out the minimum...
min_rast <- min(unique(model_spat_raster$allpoints_bioclim_canopy_dem))
# and maximum values from the SpatRaster
max_rast <- max(unique(model_spat_raster$allpoints_bioclim_canopy_dem))

# create reclassification vector: min, max, 0
reclass_vec <- c(min_rast, max_rast, 0)

# create reclassification matrix
reclass_matrix <- matrix(reclass_vec, ncol = 3, byrow = TRUE)
# this will be used to set all values 
# between (and including) the minimum and maximum to zero

# reclassify raster based on matrix
model_template <- terra::classify(model_spat_raster, # original raster
                           reclass_matrix, # reclassification matrix
                           include.lowest = TRUE, # include minimum value
                           right = FALSE # intervals are open on right and 
                           # closed on left, meaning that we'll include the highest as well
                           )

# check to see if this worked through simple visualization
plot(model_template)

# [come back] mask template
# mask this template area to the southern region of the LPNF to speed up distance calculations

model_template_south <- mask(model_template, # keep values in this raster when
                             lpnf_boundary_south) # covered by this mask

plot(model_template_south)
```

Note that all values are "0"! 


### Extract points 

We're trying to calculate the distance from the centroid of each raster cell to the nearest trail and road.
To do this, we'll first extract points from the centroids of all raster cells in a RasterLayer as SpatialPoints. 

We will calculate distance using `st_distance()`, so we'll also need to convert the SpatialPoints DataFrame to a simple feature (`sf`) object.

```{r}
# remember: we also read in our model template as a RasterLayer (rather than SpatRaster)
# and named it 'model_raster_layer'

# [come back in spring] note for later: it would make more sense to crop (mask()) to the smaller extent first (southern LPNF boundary)

# [come back in spring] omit in final cleaning of this doc?
# technique 1: convert to "Spatial Points" object  (scrapped)
#points <- as(model_raster_layer, "SpatialPoints")
# plot(points)
# points <- points %>% st_transform(crs = st_crs(roads_prep))
# distance_test <- rgeos::gDistance(points, roads_prep, byid = TRUE)

# Extract points from RasterLayer, turn into SpatialPointsDataFrame ----

# technique 2: convert raster to Points (centroids)
spatial_points <- raster::rasterToPoints(model_raster_layer,
                                    spatial = TRUE) # return a SpatialPointsDataFrame object

# trying with cropped model raster
# mask model raster layer
raster_layer_south <- raster::raster(model_template_south)

spatial_points_south <- raster::rasterToPoints(raster_layer_south,
                                               spatial = TRUE)

# convert centroids points to sf object ----
centroid_points <- st_as_sf(spatial_points, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(only_roads)) # keep in the same CRS: EPSG 4326

# performing this step for masked southern region points
centroid_points_south <- st_as_sf(spatial_points_south, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(only_roads)) # keep in the same CRS: EPSG 4326

# check that CRS match
# st_crs(centroid_points) == st_crs(only_roads) # returns TRUE
```


## Calculate Distance

We will calculate the distance from these centroid points to all lines in the roads and trails subsets.

We'll then select the minimum distance between each point (representing the centroid of a raster cell in our model template raster) and a trail or road. This minimum value will represent the distance between each cell and the nearest road or trail. 


```{r masked-distance-calc}
# =========== Calculate distances =========================
# calculate distances between all raster cell centroids and every line (trail or road) in the multilinestring sf dataframe object (roads_prep, trails_prep), then convert to data frame, where each row represents a point (centroid of raster cell) and columns represent the distance to every road (multilinestring in the roads_prep data set)


# attempting this with the raster cropped to the southern region 
system.time(
distance_to_roads_south <- st_distance(centroid_points_south, only_roads) %>% 
  data.frame()
)
#    user  system elapsed 
# 57.429   0.474  57.783 

system.time(
distance_to_trails_south <- st_distance(centroid_points_south, only_trails) %>% 
  data.frame()
)
#    user  system elapsed 
# 125.401   1.082 126.133
```


Don't run these unless you want to calculate the distance to roads and trails in the whole north + south extent + extra areas around!! (takes a long time and we crop it anyway but could be useful for some application later on)

```{r og-distance-calc}
# note: these may take several minutes to run

# distance to roads
distance_to_roads <- st_distance(centroid_points, only_roads) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid

# distance to trails
distance_to_trails <- st_distance(centroid_points, only_trails) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid
```

Finding distance to nearest road or trail

```{r nearest-distance-south}
# ========== Find nearest line ===================
# for each point (row), take the minimum value, which represents the distance to the nearest road or trail
nearest_road_south <- apply(distance_to_roads_south, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest road) as data frame


nearest_trail_south <- apply(distance_to_trails_south, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest trail) as data frame


# ======= Join distances and geometries ======================= 
# bringing geometry column in, saving minimum distance to road as an sf object
nearest_road_w_geom_south <- bind_cols(centroid_points_south, nearest_road_south)

# bringing geometry column in, saving minimum distance to trail as an sf object
nearest_trail_w_geom_south <- bind_cols(centroid_points_south, nearest_trail_south)


# renaming distance column, removing irrelevant column from sf data frame
road_distance_sf_south <- nearest_road_w_geom_south %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)

# renaming distance column, removing irrelevant column from sf data frame
trail_distance_sf_south <- nearest_trail_w_geom_south %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)
```


Again, don't run this chunk unless you want to work with the full area (not cropped to south)

```{r og-nearest-distance, eval=FALSE}
# ========== Find nearest line ===================
# for each point (row), take the minimum value, which represents the distance to the nearest road or trail
nearest_road_south <- apply(distance_to_roads, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest road) as data frame


nearest_trail_south <- apply(distance_to_trails, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest trail) as data frame


# ======= Join distances and geometries ======================= 
# bringing geometry column in, saving minimum distance to road as an sf object
nearest_road_w_geom <- bind_cols(centroid_points, nearest_road)

# bringing geometry column in, saving minimum distance to road as an sf object
nearest_trail_w_geom <- bind_cols(centroid_points, nearest_trail)


# renaming distance column, removing irrelevant column from sf data frame
road_distance_sf <- nearest_road_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)

# renaming distance column, removing irrelevant column from sf data frame
trail_distance_sf <- nearest_trail_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)


```



## Rasterize distances

Now we'll make a raster of the distance from each point (centroid of a raster cell, which came from the model output raster we used as a template) to the nearest line (trail or road).

When we rasterize, we'll be using the `stars` object version of our template raster, called `stars_temp_raster` within `st_rasterize()`

[come back in spring]
Note: I tried to crop/mask the stars object version of the model template to the southern region in a few ways but failed :) 

```{r}
# crop/mask stars temp raster to southern region of the forest
# stars_raster_south <- mask(stars_temp_raster,
#                            lpnf_boundary_south)
# make a copy of the stars template raster
# stars_raster_south <- stars_temp_raster

# make lpnf boundary a stars object
# lpnf_south_stars <- st_as_stars(lpnf_boundary_south)

# set values to NA if NA in the lpnf_boundary_south

# stars_raster_south[is.na(lpnf_boundary_south)] = NA
```


```{r}
# we'll rasterize by using a template raster -- the same model output from earlier

# the template needs to be a stars object in st_rasterize
# the stars_temp_raster object we created earlier 

# roads ----
# rasterize sf data frame, then convert to SpatRaster
road_distance_raster <- terra::rasterize(x = road_distance_sf_south,
                                         y = model_template) # object of class SpatRaster
# trails ----
# rasterize sf data frame, then convert to SpatRaster
trail_distance_raster <- st_rasterize(trail_distance_sf_south,
                                 template = stars_temp_raster) %>% 
  rast() # convert to SpatRaster


# plot to check the output of this step
plot(road_distance_raster)

```

Shows that we've cropped the distance area but not the full template raster (see earlier note about difficulty cropping/masking stars object)

## Crop & Rescale 

We'll first crop our distance raster to the southern region of the LPNF, then rescale our distances to fit from 0 to 1, with an added step (1 - rescaling) to ensure that 1 indicates high physical accessibility (closer to trails, roads) and 0 indicates low physical accessibility (farther away from trails, roads).


```{r rescale-roads}
# ============= Crop ==============
# [come back in spring]: we'll need to update this part to incorporate Northern data

# we'll use the southern LPNF boundary as a mask to crop the 
# roads and trails rasters to the southern region of the LPNF boundary first,
# using the lpnf_boundary_south object created earlier

# crop roads raster
road_distance_crop <- mask(road_distance_raster, # keep the values of this raster
                           lpnf_boundary_south) # where cells are covered by this "mask" 

# crop trails raster
trail_distance_crop <- mask(trail_distance_raster,
                            lpnf_boundary_south)

# =========== Rescale ============================
# rescale each raster of distance to roads and trails from 0 to 1:

# first, compute min and max
min_max_road <- minmax(road_distance_crop) 
min_max_trail <- minmax(trail_distance_crop) 
# returns min and max matrix with min distance in row 1, max as row 2

# rescale: 
# for every raster cell:
# 1 - (subtract min value from distance, divide by (max - min)) 
# so that 1 is closest, 0 is farthest 
road_dist_rescaled <- 1 - ((road_distance_crop - min_max_road[1,]) / (min_max_road[2,] - min_max_road[1,]))

# perform same rescaling for trails
trail_dist_rescaled <- 1 - ((trail_distance_crop - min_max_trail[1,]) / (min_max_trail[2,] - min_max_trail[1,]))

# plot to check
plot(road_dist_rescaled)
plot(trail_dist_rescaled)

```


## Plotting
```{r basic-roads-plot}
leaflet() %>% 
  addProviderTiles(provider = providers$Esri.WorldTopoMap) %>% 
  addRasterImage(x = road_dist_rescaled,
              opacity = 0.8)

leaflet() %>% 
  addProviderTiles(provider = providers$Esri.WorldTopoMap) %>% 
  addRasterImage(x = trail_dist_rescaled,
              opacity = 0.8)

# leaflet() %>% 
#   addProviderTiles(provider = providers$Esri.WorldTerrain) %>% 
#   addRasterImage(x = road_dist_raster,
#               opacity = 0.8)
```


I'm still struggling to successfully source the script...
```{r}
# plot
source(here("scripts/addLegend_decreasing.R"))

mapPredVals_Ac <- getRasterVals(roads_rescaled)

colors <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")

numPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)
rasPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)

leaflet(
  # options = leafletOptions(crs = leafletCRS("L.CRS.EPSG4326"))
        ) %>% 
 addProviderTiles(providers$Esri.WorldTopoMap) %>%
addRasterImage(x = roads_rescaled,
              # fillColor = "darkgreen",
               colors = rasPal,
              # weight = 1.5,
              # opacity = 0.6
              ) %>%
  addLegend_decreasing("bottomleft", pal = numPal, values = mapPredVals_Ac, title = "Accessibility Score") %>%
  addPolygons(data = lpnf_boundary, fill = FALSE,
              weight = 2, color = "darkgreen", opacity = 0.7)
```




```{r}
# distance_to_roads <- distance_to_road %>%
#   st_as_sf(coords = c("x", "y"),
#            crs = st_crs(centroid_points))

#heatmap_raster <- raster(model_raster_layer)

# values(heatmap_raster) <- min_distances

# st_write(distance_to_road, here::here(), "distance_to_road.shp")
```


## Saving

Once we've viewed the output of our final rescaling steps, we can save the distance rasters as tifs to the appropriate data storage locations.

```{r saving, eval=FALSE}


```



```{r}
# trying to do this with terra instead
trail_north_vect <- terra::vect(trail_distance_sf_north)


#trail_north_rast <- terra::rasterize(trail_north_vect, model_template_north,
                                     field = "distance", update = TRUE)
# did not work :(


#plot(trail_north_rast, col = terrain.colors(100))

```