---
author: "Anna Ramji"
title: "Distance Calculations for Site Accessibility"
---


```{r library}
# load necessary packages
library(tidyverse)
library(janitor)
library(sf)
library(ggspatial)
library(terra)
library(here)
library(leaflet)
library(stars)
library(gdistance)
```


```{r setup}
# read in data ----

# ------ LPNF boundary ---------
boundary <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/S_USA_AdministrativeForest.gdb/"))

lpnf_boundary <- boundary %>% 
  filter(FORESTNAME %in% c("Los Padres National Forest")) %>% 
  st_transform(crs = "EPSG:4326")


# ---- TRAILS & ROADS ----------------
# read in LPNF trails data 
trails_data <- st_read(here("~/../../capstone/milkweedmod/data/2023_Regional_Trails_and_Roads_lines/2023_Regional_Trails_and_Roads_lines.shp"))

# reproject trails data
trails_reprojected <- trails_data %>% 
  st_transform(crs = st_crs(lpnf_boundary)) %>% 
  st_zm() %>%  # remove z-dimension
  janitor::clean_names() # tidy up column names

# check that crs match
# st_crs(lpnf_boundary) == st_crs(trails_reprojected)


# trails subset
only_trails <- trails_reprojected %>% 
  filter(type == "Trail")   # 1283 observations

# roads subset
only_roads <- trails_reprojected %>% 
  filter(type == "Road") # 744 obs

# selecting relevant columns, converting to x,y
trail_raster_prep <- only_trails %>% 
  dplyr::select(type, geometry) %>% 
  st_cast("LINESTRING") # convert to linestring (not multilinestring) [come back]

# make it into a raster
trails_raster <- st_rasterize(trail_raster_prep, field = "type", fun = "constant")


roads_prep <- only_roads %>% 
  dplyr::select(type, geometry)
# %>% 
#   st_cast("LINESTRING")


# ------ read in model raster ----------
# to make it a SpatRaster (terra), not a RasterLayer (raster)
model_raster <- terra::rast(here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))



```



### Setting raster cells to 0 to make a blank template for baseline distance calculations 


```{r}
plot(model_raster)

# pull out the minimum
min_rast <- min(unique(model_raster$allpoints_bioclim_canopy_dem))
# and maximum values 
max_rast <- max(unique(model_raster$allpoints_bioclim_canopy_dem))

# set all values between the minimum and maximum to zero (all values!)
reclass_vec <- c(min_rast, max_rast, 0)

# create reclassification matrix
reclass_matrix <- matrix(reclass_vec, ncol = 3, byrow = TRUE)

# classify(raster, reclassification matrix, include.lowest = true???, right = NA)

# reclassify raster based on matrix
model_template <- terra::classify(model_raster, # original raster
                           reclass_matrix, # reclassification matrix
                           include.lowest = TRUE,
                           right = FALSE
                           )


plot(model_template)
```



## Extract points 

from centroids of all raster cells as Spatial Points for distance calculations

```{r}
# read in as RasterLayer (rather than SpatRaster)
model_raster_layer <- raster::raster(model_template)

# technique 1: convert to "Spatial Points" object 
points <- as(model_raster_layer, "SpatialPoints")

plot(points)

# points <- points %>% st_transform(crs = st_crs(roads_prep))

# distance_test <- rgeos::gDistance(points, roads_prep, byid = TRUE)

# technique 2: convert raster to Points 
centroids <- raster::rasterToPoints(model_raster_layer,
                                    spatial = TRUE) # return a SpatialPointsDataFrame object

# convert centroids to points
centroid_points <- st_as_sf(centroids, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(roads_prep))

# check that CRS match
st_crs(centroid_points) == st_crs(roads_prep) # returns TRUE

# this takes many minutes to run :) 
distance_to_points <- st_distance(centroid_points, roads_prep)

# convert to data frame, where each row represents a point (centroid of raster cell) and columns represent the distance to every road (multilinestring in the roads_prep data set)
roads_distances <- distance_to_points %>% data.frame() 

# for each point (row), take the minimum value, which represents the distance to the nearest road
min_distances <- apply(roads_distances, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest road) as data frame

# bringing geometry column in, saving distance to road as sf object
min_distance_with_geom <- bind_cols(centroid_points, min_distances)

# renaming and adding ID column, selecting relevant columns 
distance_to_roads <- min_distance_with_geom %>% 
  rename(distance = ".") %>% 
#  mutate(ID = row_number()) %>% 
#  relocate(ID, .before = distance) %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)
```


```{r}
# the template needs to be a stars object in st_rasterize
stars_temp_raster <- stars::read_stars(here::here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# rasterize sf data frame, then convert to spatRaster
road_dist_raster <- st_rasterize(distance_to_roads, template = stars_temp_raster) %>% 
  rast() # convert to spatRaster

# plot to check the output of this step
#plot(road_dist_raster)

```


```{r rescale-roads}
# rescale distance to roads from 0 to 1

# we'll crop to the LPNF boundary first [change this to southern extent only?]
lpnf_boundary_south <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_south/lpnf_boundary_south.shp"))

cropped_roads_dist <- mask(road_dist_raster, lpnf_boundary_south)

# compute min and max, rescale
min_max_roads <- minmax(cropped_roads_dist) 
# returns min and max matrix with min distance in row 1, max as row 2

# rescale: for every cell, 1 - (subtract min value from distance, divide by (max - min)) (so that 1 is closest, 0 is farthest)
roads_rescaled <- 1 - ((cropped_roads_dist - min_max_roads[1,]) / (min_max_roads[2,] - min_max_roads[1,]))

# plot to check
plot(roads_rescaled)
```


```{r basic-roads-plot}
leaflet() %>% 
  addProviderTiles(provider = providers$Esri.WorldTopoMap) %>% 
  addRasterImage(x = roads_rescaled,
              opacity = 0.8)

# leaflet() %>% 
#   addProviderTiles(provider = providers$Esri.WorldTerrain) %>% 
#   addRasterImage(x = road_dist_raster,
#               opacity = 0.8)
```
```{r}
# plot
source(here("scripts/addLegend_decreasing.R"))

mapPredVals_Ac <- getRasterVals(roads_rescaled)

colors <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")

numPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)
rasPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)

leaflet(
  # options = leafletOptions(crs = leafletCRS("L.CRS.EPSG4326"))
        ) %>% 
 addProviderTiles(providers$Esri.WorldTopoMap) %>%
addRasterImage(x = roads_rescaled,
              # fillColor = "darkgreen",
               colors = rasPal,
              # weight = 1.5,
              # opacity = 0.6
              ) %>%
  addLegend_decreasing("bottomleft", pal = numPal, values = mapPredVals_Ac, title = "Accessibility Score") %>%
  addPolygons(data = lpnf_boundary, fill = FALSE,
              weight = 2, color = "darkgreen", opacity = 0.7)
```




```{r}
# distance_to_roads <- distance_to_road %>%
#   st_as_sf(coords = c("x", "y"),
#            crs = st_crs(centroid_points))

#heatmap_raster <- raster(model_raster_layer)

# values(heatmap_raster) <- min_distances

# st_write(distance_to_road, here::here(), "distance_to_road.shp")
```


```{r}
ggplot(data = distance_to_roads) + 
  geom_sf(aes(fill = distance))
```




```{r}

# test_raster <- raster(extent(model_raster), 249, 387)
# 
# plot(test_raster)


# ggplot() +
#   geom_sf(data = roads_prep,
#           aes(),
#           color = "black") +
#   geom_sf(data = centroids,
#           aes)

```

