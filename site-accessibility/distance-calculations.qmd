---
author: "Anna Ramji"
title: "Distance Calculations for Site Accessibility"
---

# Calculating distance from raster cell centroids to roads & trails

## Setup


### Load Packages
```{r library}
# load necessary packages
library(tidyverse)
library(janitor)
library(sf)
library(ggspatial)
library(terra)
library(here)
library(leaflet)
library(stars)
library(gdistance)
```

### Read in Data
```{r data}
# read in data ----

# ------ LPNF boundary shapefiles ---------
# Southern region
lpnf_boundary_south <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_south/lpnf_boundary_south.shp"))

# Northern region (once we have trail and road data for the North)
lpnf_boundary_north <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_north/lpnf_boundary_north.shp"))


# ------ Trails & Roads shapefile ----------------
# read in LPNF trails data 
trails_and_roads <- st_read(here("~/../../capstone/milkweedmod/data/2023_Regional_Trails_and_Roads_lines/2023_Regional_Trails_and_Roads_lines.shp"))


# -------- Model raster ---------------------------
# We'll read in a .tif of the species distribution model output 
# to use as a template when we convert our shapefiles into rasters

# first as a SpatRaster (terra), to perform reclassification 
model_spat_raster <- terra::rast(here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# then as a RasterLayer (raster), to extract points in our distance calculation steps
model_raster_layer <- raster::raster(model_spat_raster)

# finally, the template needs to be a stars object when we rasterize with st_rasterize(), 
stars_temp_raster <- stars::read_stars(here::here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# optional data exploration/visualization
# plot(model_spat_raster)
# head(trails_and_roads)
# st_crs(model_raster_layer)
```

## Wrangle & tidy data

As we're working with geospatial data, it's important to make sure that our data is projected in the same coordinate reference system (CRS), and that it shares the same resolution and extent when we go to plot or combine multiple geospatial data elements. 

We are working in World Geodetic System 1984 (WGS 84) **EPSG 4326**. Fortunately, our tidied data (LPNF boundary and model output raster) are already in this CRS. 

```{r check}
# double-check to see that our data is in the same CRS
print("The CRS of the LPNF boundary and the model output match:")
st_crs(lpnf_boundary_south) == st_crs(model_spat_raster)

print("The CRS of the model output and the Trails & Roads data match:")
st_crs(model_spat_raster) == st_crs(trails_and_roads)
```
As the Trails & Roads data is not in the same CRS, we'll start by reprojecting the trails & roads data to match, and then create two subsets for trail data and road data (all in the Southern region of the forest.)
**[Note: we'll change this part once we have our cleaned data products script working]**

```{r tidy}
# ------- tidy trails & roads data -----------------
trails_roads_reprojected <- trails_and_roads %>% 
  st_transform(crs = st_crs(lpnf_boundary_south)) %>% # reproject CRS to EPSG 4326
  st_zm() %>%  # remove z-dimension
  janitor::clean_names() # tidy up column names


# check that crs match
print("The CRS of the model output and the Trails & Roads data match:")
st_crs(lpnf_boundary_south) == st_crs(trails_roads_reprojected)
```

### Create subsets

Here we'll separate the trails & roads data into two separate datasets -- trails and roads -- before selecting relevant columns to use when calculating distance.

*Note: we are not taking closed or limited-access roads or trails into account in our model and index creation -- if the trail or road exists, we're counting it. If you want to omit certain types of roads/trails, you can filter out certain variables to make updated subsets using `dplyr::filter(variable_name == "Condition")`, where "Condition" is whatever condition you've identified when `View`ing the dataframe.

```{r tidy}
# note: the geometries are MULTILINESTRINGS 
# (lines that have multiple + different start and end points)

# trails subset
only_trails <- trails_roads_reprojected %>% 
  filter(type == "Trail") %>%   # 1283 observations
  dplyr::select(type, geometry) # select relevant columns

# roads subset
only_roads <- trails_roads_reprojected %>% 
  filter(type == "Road") %>%  # 744 obs
  dplyr::select(type, geometry) # select relevant columns

# optional data exploration/visualization
# plot(only_trails)
# plot(only_roads)
```


## Model Raster

### Raster reclassification: 
**Make a blank *template* for baseline distance calculations **

(Note: If we were working with a shapefile instead of a raster, we could simply add a column of 0s (or 1s), then rasterize, as we did when working with the land ownership mask).

First, we'll find the minimum and maximum values of our model raster, then create a reclassification matrix which will have 3 values: min, max, and 0. Then, we'll use that matrix to reclassify the model raster such that all values from min to max are equal to 0.

```{r reclassify-raster}
# pull out the minimum...
min_rast <- min(unique(model_spat_raster$allpoints_bioclim_canopy_dem))
# and maximum values from the SpatRaster
max_rast <- max(unique(model_spat_raster$allpoints_bioclim_canopy_dem))

# create reclassification vector: min, max, 0
reclass_vec <- c(min_rast, max_rast, 0)

# create reclassification matrix
reclass_matrix <- matrix(reclass_vec, ncol = 3, byrow = TRUE)
# this will be used to set all values 
# between (and including) the minimum and maximum to zero

# reclassify raster based on matrix
model_template <- terra::classify(model_spat_raster, # original raster
                           reclass_matrix, # reclassification matrix
                           include.lowest = TRUE, # include minimum value
                           right = FALSE # intervals are open on right and 
                           # closed on left, meaning that we'll include the highest as well
                           )

# check to see if this worked through simple visualization
plot(model_template)
```

Note that all values are "0"! 


### Extract points 

We're trying to calculate the distance from the centroid of each raster cell to the nearest trail and road.
To do this, we'll first extract points from the centroids of all raster cells in a RasterLayer as SpatialPoints. 

We will calculate distance using `st_distance()`, so we'll also need to convert the SpatialPoints DataFrame to a simple feature (`sf`) object.

```{r}
# remember: we also read in our model template as a RasterLayer (rather than SpatRaster)
# and named it 'model_raster_layer'

# [come back in spring] note for later: it would make more sense to crop (mask()) to the smaller extent first (southern LPNF boundary)

# [come back in spring] omit in final cleaning of this doc?
# technique 1: convert to "Spatial Points" object  (scrapped)
#points <- as(model_raster_layer, "SpatialPoints")
# plot(points)
# points <- points %>% st_transform(crs = st_crs(roads_prep))
# distance_test <- rgeos::gDistance(points, roads_prep, byid = TRUE)

# Extract points from RasterLayer, turn into SpatialPointsDataFrame ----

# technique 2: convert raster to Points (centroids)
centroids <- raster::rasterToPoints(model_raster_layer,
                                    spatial = TRUE) # return a SpatialPointsDataFrame object

# convert centroids points to sf object ----
centroid_points <- st_as_sf(centroids, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(only_roads)) # keep in the same CRS: EPSG 4326

# check that CRS match
#st_crs(centroid_points) == st_crs(roads_prep) # returns TRUE
```


```{r distance-calc}
# =========== Calculate distances =========================
# between all raster cell centroids and every line (trail or road) in the multilinestring sf dataframe object (roads_prep, trails_prep), then convert to data frame, where each row represents a point (centroid of raster cell) and columns represent the distance to every road (multilinestring in the roads_prep data set)
# this may take several minutes to run

# distance to roads
distance_to_roads <- st_distance(centroid_points, roads_prep) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid

# distance to trails
distance_to_trails <- st_distance(centroid_points, trails_prep) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid

# ========== Find nearest line ===================
# for each point (row), take the minimum value, which represents the distance to the nearest road or trail
nearest_road <- apply(distance_to_roads, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest road) as data frame


nearest_trail <- apply(distance_to_trails, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest trail) as data frame

# ======= Join distances and geometries ======================= 
# bringing geometry column in, saving minimum distance to road as an sf object
nearest_road_w_geom <- bind_cols(centroid_points, nearest_road)

# bringing geometry column in, saving minimum distance to road as an sf object
nearest_trail_w_geom <- bind_cols(centroid_points, nearest_trail)


# renaming distance column, removing irrelevant column from sf data frame
road_distance_sf <- nearest_road_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)

# renaming distance column, removing irrelevant column from sf data frame
trail_distance_sf <- nearest_trail_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)


```

## Rasterize: Get raster of distance to nearest line
```{r}
# we'll rasterize by using a template raster -- the same model output from earlier

# the template needs to be a stars object in st_rasterize
stars_temp_raster <- stars::read_stars(here::here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# rasterize sf data frame, then convert to spatRaster
road_distance_raster <- st_rasterize(road_distance_sf,
                                 template = stars_temp_raster) %>% 
  rast() # convert to spatRaster


# rasterize sf data frame, then convert to spatRaster
trail_distance_raster <- st_rasterize(trail_distance_sf,
                                 template = stars_temp_raster) %>% 
  rast() # convert to spatRaster


# plot to check the output of this step
#plot(road_dist_raster)

```

## Rescaling and cropping to southern LPNF buffer
```{r rescale-roads}
# ============= Crop ==============

# we'll crop to the LPNF boundary first 
lpnf_boundary_south <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_south/lpnf_boundary_south.shp"))

# use the southern LPNF boundary as a mask to crop the roads and trails rasters ----
# crop roads
road_distance_crop <- mask(road_distance_raster, lpnf_boundary_south)

# crop trails
trail_distance_crop <- mask(trail_distance_raster, lpnf_boundary_south)

# =========== Rescale ============================
# rescale each raster of distance to roads and trails from 0 to 1:

# first, compute min and max
min_max_road <- minmax(road_distance_crop) 
min_max_trail <- minmax(trail_distance_crop) 
# returns min and max matrix with min distance in row 1, max as row 2

# rescale: 
# for every raster cell:
# 1 - (subtract min value from distance, divide by (max - min)) 
# so that 1 is closest, 0 is farthest 
road_dist_rescaled <- 1 - ((road_distance_crop - min_max_road[1,]) / (min_max_road[2,] - min_max_road[1,]))

# perform same rescaling for trails
trail_dist_rescaled <- 1 - ((trail_distance_crop - min_max_trail[1,]) / (min_max_trail[2,] - min_max_trail[1,]))

# plot to check
plot(road_dist_rescaled)
plot(trail_dist_rescaled)

```


## Plotting
```{r basic-roads-plot}
leaflet() %>% 
  addProviderTiles(provider = providers$Esri.WorldTopoMap) %>% 
  addRasterImage(x = road_dist_rescaled,
              opacity = 0.8)

# leaflet() %>% 
#   addProviderTiles(provider = providers$Esri.WorldTerrain) %>% 
#   addRasterImage(x = road_dist_raster,
#               opacity = 0.8)
```


I'm still struggling to successfully source the script...
```{r}
# plot
source(here("scripts/addLegend_decreasing.R"))

mapPredVals_Ac <- getRasterVals(roads_rescaled)

colors <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")

numPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)
rasPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)

leaflet(
  # options = leafletOptions(crs = leafletCRS("L.CRS.EPSG4326"))
        ) %>% 
 addProviderTiles(providers$Esri.WorldTopoMap) %>%
addRasterImage(x = roads_rescaled,
              # fillColor = "darkgreen",
               colors = rasPal,
              # weight = 1.5,
              # opacity = 0.6
              ) %>%
  addLegend_decreasing("bottomleft", pal = numPal, values = mapPredVals_Ac, title = "Accessibility Score") %>%
  addPolygons(data = lpnf_boundary, fill = FALSE,
              weight = 2, color = "darkgreen", opacity = 0.7)
```




```{r}
# distance_to_roads <- distance_to_road %>%
#   st_as_sf(coords = c("x", "y"),
#            crs = st_crs(centroid_points))

#heatmap_raster <- raster(model_raster_layer)

# values(heatmap_raster) <- min_distances

# st_write(distance_to_road, here::here(), "distance_to_road.shp")
```


## Saving

Once we've viewed the output of our final rescaling steps, we can save the distance rasters as tifs to the appropriate data storage locations.

```{r saving, eval=FALSE}


```

