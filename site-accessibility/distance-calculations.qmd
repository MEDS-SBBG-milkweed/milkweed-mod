---
author: "Anna Ramji"
title: "Distance Calculations for Site Accessibility"
---


```{r library}
# load necessary packages
library(tidyverse)
library(janitor)
library(sf)
library(ggspatial)
library(terra)
library(here)
library(leaflet)
library(stars)
library(gdistance)
```


```{r setup}
# read in data ----

# ------ LPNF boundary ---------
boundary <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/S_USA_AdministrativeForest.gdb/"))

lpnf_boundary <- boundary %>% 
  filter(FORESTNAME %in% c("Los Padres National Forest")) %>% 
  st_transform(crs = "EPSG:4326")


# ---- TRAILS & ROADS ----------------
# read in LPNF trails data 
trails_data <- st_read(here("~/../../capstone/milkweedmod/data/2023_Regional_Trails_and_Roads_lines/2023_Regional_Trails_and_Roads_lines.shp"))

# reproject trails data
trails_reprojected <- trails_data %>% 
  st_transform(crs = st_crs(lpnf_boundary)) %>% 
  st_zm() %>%  # remove z-dimension
  janitor::clean_names() # tidy up column names

# check that crs match
# st_crs(lpnf_boundary) == st_crs(trails_reprojected)


# trails subset
only_trails <- trails_reprojected %>% 
  filter(type == "Trail")   # 1283 observations

# roads subset
only_roads <- trails_reprojected %>% 
  filter(type == "Road") # 744 obs

# selecting relevant columns, converting to x,y
trails_prep <- only_trails %>% 
  dplyr::select(type, geometry) 
#  st_cast("LINESTRING") # convert to linestring (not multilinestring) [come back]

# make it into a raster
#trails_raster <- st_rasterize(trail_raster_prep, field = "type", fun = "constant")


roads_prep <- only_roads %>% 
  dplyr::select(type, geometry)
# %>% 
#   st_cast("LINESTRING")


# ------ read in model raster ----------
# to make it a SpatRaster (terra), not a RasterLayer (raster)
model_raster <- terra::rast(here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))



```



### Setting raster cells to 0 to make a blank template for baseline distance calculations 


```{r}
plot(model_raster)

# pull out the minimum
min_rast <- min(unique(model_raster$allpoints_bioclim_canopy_dem))
# and maximum values 
max_rast <- max(unique(model_raster$allpoints_bioclim_canopy_dem))

# set all values between the minimum and maximum to zero (all values!)
reclass_vec <- c(min_rast, max_rast, 0)

# create reclassification matrix
reclass_matrix <- matrix(reclass_vec, ncol = 3, byrow = TRUE)

# classify(raster, reclassification matrix, include.lowest = true???, right = NA)

# reclassify raster based on matrix
model_template <- terra::classify(model_raster, # original raster
                           reclass_matrix, # reclassification matrix
                           include.lowest = TRUE,
                           right = FALSE
                           )


plot(model_template)
```



## Extract points 

from centroids of all raster cells as Spatial Points for distance calculations

```{r}
# read in as RasterLayer (rather than SpatRaster)
model_raster_layer <- raster::raster(model_template)

# note for later: it would make more sense to crop (mask()) to the smaller extent first (southern LPNF boundary)

# technique 1: convert to "Spatial Points" object  (scrapped)
#points <- as(model_raster_layer, "SpatialPoints")
# plot(points)
# points <- points %>% st_transform(crs = st_crs(roads_prep))
# distance_test <- rgeos::gDistance(points, roads_prep, byid = TRUE)

# technique 2: convert raster to Points (centroids)
centroids <- raster::rasterToPoints(model_raster_layer,
                                    spatial = TRUE) # return a SpatialPointsDataFrame object

# convert centroids to points ----
centroid_points <- st_as_sf(centroids, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(roads_prep))

# check that CRS match
#st_crs(centroid_points) == st_crs(roads_prep) # returns TRUE

# =========== Calculate distances =========================
# between all raster cell centroids and every line (trail or road) in the multilinestring sf dataframe object (roads_prep, trails_prep), then convert to data frame, where each row represents a point (centroid of raster cell) and columns represent the distance to every road (multilinestring in the roads_prep data set)
# this may take several minutes to run

# distance to roads
distance_to_roads <- st_distance(centroid_points, roads_prep) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid

# distance to trails
distance_to_trails <- st_distance(centroid_points, trails_prep) %>% 
  data.frame() # convert to data frame where each row represents a raster cell centroid

# ========== Find nearest line ===================
# for each point (row), take the minimum value, which represents the distance to the nearest road or trail
nearest_road <- apply(distance_to_roads, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest road) as data frame


nearest_trail <- apply(distance_to_trails, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame() # save output (distance to nearest trail) as data frame

# ======= Join distances and geometries ======================= 
# bringing geometry column in, saving minimum distance to road as an sf object
nearest_road_w_geom <- bind_cols(centroid_points, nearest_road)

# bringing geometry column in, saving minimum distance to road as an sf object
nearest_trail_w_geom <- bind_cols(centroid_points, nearest_trail)


# renaming distance column, removing irrelevant column from sf data frame
road_distance_sf <- nearest_road_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)

# renaming distance column, removing irrelevant column from sf data frame
trail_distance_sf <- nearest_trail_w_geom %>% 
  rename(distance = ".") %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)


```

## Rasterize: Get raster of distance to nearest line
```{r}
# we'll rasterize by using a template raster -- the same model output from earlier

# the template needs to be a stars object in st_rasterize
stars_temp_raster <- stars::read_stars(here::here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))

# rasterize sf data frame, then convert to spatRaster
road_distance_raster <- st_rasterize(road_distance_sf,
                                 template = stars_temp_raster) %>% 
  rast() # convert to spatRaster


# rasterize sf data frame, then convert to spatRaster
trail_distance_raster <- st_rasterize(trail_distance_sf,
                                 template = stars_temp_raster) %>% 
  rast() # convert to spatRaster


# plot to check the output of this step
#plot(road_dist_raster)

```

## Rescaling and cropping to southern LPNF buffer
```{r rescale-roads}
# ============= Crop ==============

# we'll crop to the LPNF boundary first [change this to southern extent only?]
lpnf_boundary_south <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/lpnf_boundary_south/lpnf_boundary_south.shp"))

# use the southern LPNF boundary as a mask to crop the roads and trails rasters ----
# crop roads
road_distance_crop <- mask(road_distance_raster, lpnf_boundary_south)

# crop trails
trail_distance_crop <- mask(trail_distance_raster, lpnf_boundary_south)

# =========== Rescale ============================
# rescale each raster of distance to roads and trails from 0 to 1:

# first, compute min and max
min_max_road <- minmax(road_distance_crop) 
min_max_trail <- minmax(trail_distance_crop) 
# returns min and max matrix with min distance in row 1, max as row 2

# rescale: 
# for every raster cell:
# 1 - (subtract min value from distance, divide by (max - min)) 
# so that 1 is closest, 0 is farthest 
road_dist_rescaled <- 1 - ((road_distance_crop - min_max_road[1,]) / (min_max_road[2,] - min_max_road[1,]))

# perform same rescaling for trails
trail_dist_rescaled <- 1 - ((trail_distance_crop - min_max_trail[1,]) / (min_max_trail[2,] - min_max_trail[1,]))

# plot to check
plot(road_dist_rescaled)
plot(trail_dist_rescaled)

```


## Plotting
```{r basic-roads-plot}
leaflet() %>% 
  addProviderTiles(provider = providers$Esri.WorldTopoMap) %>% 
  addRasterImage(x = road_dist_rescaled,
              opacity = 0.8)

# leaflet() %>% 
#   addProviderTiles(provider = providers$Esri.WorldTerrain) %>% 
#   addRasterImage(x = road_dist_raster,
#               opacity = 0.8)
```


I'm still struggling to successfully source the script...
```{r}
# plot
source(here("scripts/addLegend_decreasing.R"))

mapPredVals_Ac <- getRasterVals(roads_rescaled)

colors <- c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c")

numPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)
rasPal <- colorNumeric(colors, mapPredVals_Ac, na.color = 'transparent', reverse = TRUE)

leaflet(
  # options = leafletOptions(crs = leafletCRS("L.CRS.EPSG4326"))
        ) %>% 
 addProviderTiles(providers$Esri.WorldTopoMap) %>%
addRasterImage(x = roads_rescaled,
              # fillColor = "darkgreen",
               colors = rasPal,
              # weight = 1.5,
              # opacity = 0.6
              ) %>%
  addLegend_decreasing("bottomleft", pal = numPal, values = mapPredVals_Ac, title = "Accessibility Score") %>%
  addPolygons(data = lpnf_boundary, fill = FALSE,
              weight = 2, color = "darkgreen", opacity = 0.7)
```




```{r}
# distance_to_roads <- distance_to_road %>%
#   st_as_sf(coords = c("x", "y"),
#            crs = st_crs(centroid_points))

#heatmap_raster <- raster(model_raster_layer)

# values(heatmap_raster) <- min_distances

# st_write(distance_to_road, here::here(), "distance_to_road.shp")
```


## Saving

Once we've viewed the output of our final rescaling steps, we can save the distance rasters as tifs to the appropriate data storage locations.

```{r saving, eval=FALSE}


```

