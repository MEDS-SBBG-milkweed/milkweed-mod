---
author: "Anna Ramji"
title: "Distance Calculations for Site Accessibility"
---


```{r library}
# load necessary packages
library(tidyverse)
library(janitor)
library(sf)
library(ggspatial)
library(terra)
library(here)
library(leaflet)
library(stars)
library(gdistance)
```


```{r setup}
# read in data ----

# ------ LPNF boundary ---------
boundary <- st_read(here("~/../../capstone/milkweedmod/data/lpnf_boundary_data/S_USA_AdministrativeForest.gdb/"))

lpnf_boundary <- boundary %>% 
  filter(FORESTNAME %in% c("Los Padres National Forest")) %>% 
  st_transform(crs = "EPSG:4326")


# ---- TRAILS & ROADS ----------------
# read in LPNF trails data 
trails_data <- st_read(here("~/../../capstone/milkweedmod/data/2023_Regional_Trails_and_Roads_lines/2023_Regional_Trails_and_Roads_lines.shp"))

# reproject trails data
trails_reprojected <- trails_data %>% 
  st_transform(crs = st_crs(lpnf_boundary)) %>% 
  st_zm() %>%  # remove z-dimension
  janitor::clean_names() # tidy up column names

# check that crs match
# st_crs(lpnf_boundary) == st_crs(trails_reprojected)


# trails subset
only_trails <- trails_reprojected %>% 
  filter(type == "Trail")   # 1283 observations

# roads subset
only_roads <- trails_reprojected %>% 
  filter(type == "Road") # 744 obs

# selecting relevant columns, converting to x,y
trail_raster_prep <- only_trails %>% 
  dplyr::select(type, geometry) %>% 
  st_cast("LINESTRING") # convert to linestring (not multilinestring)

# make it into a raster
trails_raster <- st_rasterize(trail_raster_prep, field = "type", fun = "constant")


roads_prep <- only_roads %>% 
  dplyr::select(type, geometry)
# %>% 
#   st_cast("LINESTRING")


# ------ read in model raster ----------
# to make it a SpatRaster (terra), not a RasterLayer (raster)
model_raster <- terra::rast(here("~/../../capstone/milkweedmod/data/models/allpoints_bioclim_canopy_dem.tif"))



```



### Setting raster cells to 0 to make a blank template for baseline distance calculations 


```{r}
plot(model_raster)

# pull out the minimum
min_rast <- min(unique(model_raster$allpoints_bioclim_canopy_dem))
# and maximum values 
max_rast <- max(unique(model_raster$allpoints_bioclim_canopy_dem))

# set all values between the minimum and maximum to zero (all values!)
reclass_vec <- c(min_rast, max_rast, 0)

# create reclassification matrix
reclass_matrix <- matrix(reclass_vec, ncol = 3, byrow = TRUE)

# classify(raster, reclassification matrix, include.lowest = true???, right = NA)

# reclassify raster based on matrix
model_template <- terra::classify(model_raster, # original raster
                           reclass_matrix, # reclassification matrix
                           include.lowest = TRUE,
                           right = FALSE
                           )


plot(model_template)
```



## Extract points 

from centroids of all raster cells as Spatial Points for distance calculations

```{r}

model_raster_layer <- raster::raster(model_template)

points <- as(model_raster_layer, "SpatialPoints")

plot(points)

# points <- points %>% st_transform(crs = st_crs(roads_prep))

# distance_test <- rgeos::gDistance(points, roads_prep, byid = TRUE)

centroids <- raster::rasterToPoints(model_raster_layer,
                                    spatial = TRUE) # return a spatial points data frame

# convert centroids to points
centroid_points <- st_as_sf(centroids, coords = c("x", "y")) %>% 
  st_transform(crs = st_crs(roads_prep))

# check that CRS match
st_crs(centroid_points) == st_crs(roads_prep) # returns TRUE

# this takes many minutes to run :) 
distance_to_points <- st_distance(centroid_points, roads_prep)

# convert to data frame, where each row represents a point (centroid of raster cell) and columns represent the distance to every road (multilinestring in the roads_prep data set)
roads_distances <- distance_to_points %>% data.frame() 

# Create a heatmap-like raster showing the distances
# heatmap_raster <- rasterFromXYZ(data.frame(x = centroids[,1], y = centroids[,2], z = apply(roads_distance_matrix, 1, min)))

# for each point (row), take the minimum value, which represents the distance to the nearest road
min_distances <- apply(roads_distances, 
                       MARGIN = 1, # margin, 1 = rows
                       FUN = min # function we're applying
                       ) %>% 
  data.frame()

min_distances <- bind_cols(centroid_points, min_distances)

distance_to_roads <- min_distances %>% 
  rename(distance = ".") %>% 
  mutate(ID = row_number()) %>% 
  relocate(ID, .before = distance) %>% 
  dplyr::select(-allpoints_bioclim_canopy_dem)

# distance_to_roads <- distance_to_road %>% 
#   st_as_sf(coords = c("x", "y"),
#            crs = st_crs(centroid_points))

#heatmap_raster <- raster(model_raster_layer)

# values(heatmap_raster) <- min_distances

# st_write(distance_to_road, here::here(), "distance_to_road.shp")
```



```{r}

# test_raster <- raster(extent(model_raster), 249, 387)
# 
# plot(test_raster)


ggplot() +
  geom_sf(data = roads_prep,
          aes(),
          color = "black") +
  geom_sf(data = centroids,
          aes)

```

